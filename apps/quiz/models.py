import uuid
from enum import Enum

from django.contrib.auth.models import (
    AbstractBaseUser,
    AbstractUser,
    BaseUserManager,
    PermissionsMixin,
)
from django.db import models
from django.db.models import Q
from django.contrib.auth.models import Group, Permission

# Create your models here.
# The intermediate models without specific fields will be generated by Django
# ------------- QUESTION CLASS --------------
class Dimension(models.Model):
    idD = models.SmallAutoField(primary_key=True)
    orden = models.PositiveSmallIntegerField()
    dimension = models.CharField(max_length=125)

    class Meta:
        indexes = [models.Index(fields=["dimension"])]
        ordering = ["orden"]

    def __str__(self):
        return f"ID {self.idD} Dimension {self.dimension}"


class InterestArea(models.Model):
    idA = models.SmallAutoField(primary_key=True)
    orden = models.PositiveSmallIntegerField()
    int_area = models.CharField(max_length=125)
    idD = models.ForeignKey(Dimension, on_delete=models.CASCADE, null=True)

    class Meta:
        indexes = [models.Index(fields=["int_area"])]
        ordering = ["orden"]

    def __str__(self):
        return (
            "ID "
            + str(self.idA)
            + " Orden "
            + str(self.orden)
            + " Área de Interés "
            + self.int_area
            + " Dimension "
            + self.idD.dimension
        )


class CoreContent(models.Model):
    idC = models.SmallAutoField(primary_key=True)
    core_cont = models.CharField(max_length=125)
    idA = models.ForeignKey(InterestArea, on_delete=models.CASCADE, null=True)

    class Meta:
        ordering = ["core_cont"]

    def __str__(self):
            return f"ID {self.idC}, Contenido Nuclear {self.core_cont }, Área de interés  {self.idA.int_area}"


class Question(models.Model):
    idP = models.BigAutoField(primary_key=True)
    numero = models.PositiveIntegerField(default=1)
    statement = models.CharField(max_length=500, unique=True)
    time = models.TimeField()
    difficult_level = models.PositiveSmallIntegerField()
    version = models.PositiveIntegerField(default=0)
    date = models.DateTimeField(auto_now=True)
    idD = models.ForeignKey(Dimension, on_delete=models.CASCADE, null=True)
    idA = models.ForeignKey(InterestArea, on_delete=models.CASCADE, null=True)
    idC = models.ForeignKey(CoreContent, on_delete=models.CASCADE, null=True)

    class Meta:
        indexes = [models.Index(fields=["statement", "numero", "version"])]

    def __str__(self):
        return str(
            f"ID: {self.idP}, Número: {self.numero}, Version: {self.version}, Enunciado: {self.statement}"
        )

# Class that represents the solution at all the options, relathinship many to one with question
class Option(models.Model):
    idO = models.AutoField(primary_key=True)
    option = models.CharField(max_length=25)
    question = models.ManyToManyField(
        Question, through="OptionQuestion", related_name="question_values"
    )

    class Meta:
        indexes = [models.Index(fields=["option"])]

    def __str__(self):
        return "ID " + str(self.idO) + " Opción " + self.option


class OptionQuestion(models.Model):

    # get only the solutions for each question id of all options
    class OptionQuestionManager(models.Manager):
        def get_queryset(self):
            return (
                super()
                .get_queryset()
                .values("idP")
                .exclude(Q(motive__isnull=True) | Q(motive="") | Q(motive=" "))
                .values("idP", "idO", "motive")
            )

    idP = models.ForeignKey(
        Question, on_delete=models.CASCADE, related_name="option_value_to_question"
    )
    idO = models.ForeignKey(
        Option, on_delete=models.CASCADE, related_name="option_value"
    )  # this id of the value
    motive = models.TextField(max_length=250, null=True)
    pk = models.CompositePrimaryKey("idP", "idO")

    objects = models.Manager()  # default
    solutions = OptionQuestionManager()

    def __str__(self):
        return f"Pregunta {self.idP} Valor {self.idO}"

# ------------- QUIZ CLASS --------------------
class Quiz(models.Model):
    idQ = models.AutoField(primary_key=True)
    file = models.CharField(max_length=125)
    fechaC = models.DateTimeField(auto_now_add=True)
    fechaA = models.DateTimeField(auto_now=True)
    question = models.ManyToManyField(
        "Question", through="AppearanceQuiz", related_name="question_in_each_quiz"
    )

    def __str__(self):
        return (
            f"ID: {str(self.idQ)} fecha creación: {self.fechaC} fecha actualización: {self.fechaA}"
        )

class AppearanceQuiz(models.Model):
    quiz = models.ForeignKey(Quiz, on_delete=models.CASCADE)
    question = models.ForeignKey(Question, on_delete=models.CASCADE)
    pk = models.CompositePrimaryKey("question", "quiz")

# ----------- INTERVIEWER CLASS(is MyUser) ---------
# AbstractUser to adapt default User Django Class
class MyUser(AbstractBaseUser, PermissionsMixin):

    class MyUserManager(BaseUserManager):

        def create_user(self, username=None, password=None, is_staff=False, **extra_fields):
            # extra_fields.setdefault('is_active', True)
            # if user have password it would be a admin or is_staff True
            if password is not None:
                user.set_password(password)

            user = self.model(username, password, is_staff=is_staff, **extra_fields)
            user.save()
            # if user.is_staff or user.is_superuser:
            #     type = 'interviewer'
            # else:
            #     type = 'respondant'

            # group, bool = Group.objects.get_or_create(name=type)
            # # user.groups.add(group)

            # if bool:# group.permissions.exists():
            #     assign_permissions(type)

            return user

        def create_superuser(self, username, password, **extra_fields):
            extra_fields.setdefault("is_staff", True)
            extra_fields.setdefault("is_superuser", True)
            user = self.model(username=username, **extra_fields)
            user.set_password(password)

            user.save()

            return user

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False, auto_created=True)
    username = models.CharField(max_length=256, unique=True, null=True)
    password = models.CharField(max_length=256, editable=False, null=True)
    is_staff = models.BooleanField(default=False)
    is_superuser = models.BooleanField(default=False)

    objects = MyUserManager()

    USERNAME_FIELD = "username"

    def __str__(self):
        return f"ID: {str(self.id)} usuario: {self.username} password: {self.password}"


# ------------- RESPONDANT --------------------
class ProfesionalArea(models.Model):
    idA = models.AutoField(primary_key=True)
    profarea = models.CharField(max_length=125)

    class Meta:
        ordering = ["profarea"]

    def __str__(self):
        return "ID: " + str(self.idA) + " Area Profesional: " + self.profarea


class Satisfation(models.Model):

    RANKING_INDIVIUAL = {
        "Nunca": 0,
        "De vez en cuando": 1,
        "Menos de la mitad del tiempo": 2,
        "Más de la mitad del tiempo": 3,
        "La mayor parte del tiempo": 4,
        "Todo el tiempo": 5,
    }

    idSas = models.AutoField(primary_key=True)
    questionS = models.CharField(max_length=250)
    value = models.PositiveSmallIntegerField(choices=RANKING_INDIVIUAL)


class YearAcademicLevel(models.Model):
    year = models.PositiveSmallIntegerField(primary_key=True)


class AcademicLevel(models.Model):
    class AcademicLevelTypes(models.TextChoices):
        Grado = "Grado"
        Máster = "Máster"
        Doctorado = "Doctorado"

    idAcademicLvl = models.AutoField(primary_key=True)
    academic_lvl = models.CharField(max_length=10, choices=AcademicLevelTypes)  # academic_lvl
    description = models.CharField(max_length=250, null=True)
    # null True permits set null in a database field
    year = models.ForeignKey(YearAcademicLevel, on_delete=models.CASCADE)


class Respondant(models.Model):

    class Sex(models.TextChoices):
        FEMENINO = "F", "Femenino"
        MASCULINO = "M", "Masculino"

    RANKING_GLOBAL = []
    for i in range(1, 10):
        RANKING_GLOBAL.append((i, str(i)))

    respondant = models.OneToOneField(MyUser, on_delete=models.CASCADE)
    age = models.PositiveSmallIntegerField()
    sex = models.CharField(choices=Sex)
    nationality = models.CharField(max_length=25)
    city = models.CharField(max_length=125)
    region = models.CharField(max_length=125)
    level_PBE = models.PositiveSmallIntegerField()
    PBE_knownledge = models.BooleanField(default=False)
    PBE_training = models.CharField(max_length=125, null=True)
    speciality = models.CharField(max_length=50, null=True)
    academic_level = models.ForeignKey(AcademicLevel, on_delete=models.CASCADE, null=True)

    grade = models.PositiveSmallIntegerField(choices=RANKING_GLOBAL, default=0)

    # if i change the name to reply or answer don't works but Respuesta sí.
    question = models.ManyToManyField(
        Question, through="Respuesta", related_name="respondant_answer_to_question"
    )
    # profarea =    models.ManyToManyField(ProfesionalArea, through='SatisfationGrade', related_name='profesional_area_user')
    profarea = models.ManyToManyField(ProfesionalArea)
    satisfation = models.ManyToManyField(
        Satisfation, through="SatisfationRes", related_name="satisfation_per_user"
    )

    def __str__(self):
        return f"ID: {self.respondant.id} Edad: {str(self.age)} Sexo: {self.sex} Nacionalidad: {self.nationality } Ciudad: {self.city} Región:  {self.region} Nivel académico: {self.academic_level.academic_lvl} Año del nivel académico: {self.academic_level.year} Area profesional/estudio:{self.profarea.values_list(flat=True)} Nivel de PBE: {self.level_PBE} Conocimiento en PBE {self.PBE_knownledge}  Especialidad: {self.speciality}"

class SatisfationRes(models.Model):
    idS = models.ForeignKey(Satisfation, on_delete=models.CASCADE)
    idRes = models.ForeignKey(Respondant, on_delete=models.CASCADE)
    pk = models.CompositePrimaryKey("idS", "idRes")

# ------------- ANSWER CLASS --------------
# The class name is in spanish cause django don't permit other
class Respuesta(models.Model):
    answer = models.ForeignKey(Option, on_delete=models.CASCADE, null=True)
    # models.CharField(max_length=25, editable=False, blank=False)
    time = models.TimeField(editable=False, blank=False)
    date = models.DateTimeField(auto_now_add=True)
    respondant = models.ForeignKey(Respondant, on_delete=models.CASCADE)
    question = models.ForeignKey(Question, on_delete=models.CASCADE)
    is_correct = models.BooleanField(default=False, null=True, blank=True)
    pk = models.CompositePrimaryKey("respondant", "question")

    class Meta:
        ordering = ["-date"]
        constraints = [
            models.UniqueConstraint(
                fields=["respondant", "question"], name="unique_answer_per_question"
            )
        ]

    def __str__(self):
        return f"ID {self.pk} Option  {self.answer}, Time{self.time}, question {self.question}"

# ------------------- PROFESIONALS --------------------
class Enviroment(models.Model):
    idEnv = models.AutoField(primary_key=True)
    enviroment = models.CharField(max_length=125)

    def __str__(self):
        return f"ID: {self.idEnv}, environ {self.enviroment}"

class Sector(models.Model):
    idSec = models.AutoField(primary_key=True)
    sector = models.CharField(max_length=125)

    def __str__(self):
        return f"ID: {self.idSec}, sector: {self.sector}"

class Activity(models.Model):
    idAct = models.AutoField(primary_key=True)
    activity = models.CharField(max_length=125)

    def __str__(self):
        return f"ID:  {self.idAct}, activity: {self.activity}"

class Profesional(models.Model):
    profesional = models.OneToOneField(Respondant, on_delete=models.CASCADE, primary_key=True)
    supervisor = models.BooleanField(default=False)
    dedicationW = models.PositiveIntegerField(default=0)
    years = models.PositiveIntegerField(default=0)

    activities = models.ManyToManyField(
        Activity, through="Dedication", related_name="activities_by_profesional"
    )
    sectors = models.ManyToManyField(Sector, through="Secprof", related_name="sectors_on_works")
    enviroments = models.ManyToManyField(
        Enviroment, through="Envprof", related_name="enviroments_on_works"
    )

# Intermediate class between activity and profesional to show pecentatge of time that a profesional takes to do an activity
class Dedication(models.Model):
    profesional = models.ForeignKey(
        Profesional, on_delete=models.CASCADE, related_name="id_between_activity_profesional"
    )
    activity = models.ForeignKey(Activity, on_delete=models.CASCADE)
    percentatge = models.FloatField(default=0)
    pk = models.CompositePrimaryKey("profesional", "activity")

class Envprof(models.Model):
    profesional = models.ForeignKey(Profesional, on_delete=models.CASCADE)
    enviroment = models.ForeignKey(Enviroment, on_delete=models.CASCADE)
    pk = models.CompositePrimaryKey("profesional", "enviroment")

class Secprof(models.Model):
    profesional = models.ForeignKey(Profesional, on_delete=models.CASCADE)
    sector = models.ForeignKey(Sector, on_delete=models.CASCADE)
    pk = models.CompositePrimaryKey("profesional", "sector")